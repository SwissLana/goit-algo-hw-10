# Завдання 1. Порівняння жадібного алгоритму та алгоритму динамічного програмування

## Постановка задачі

Маємо набір монет: `[50, 25, 10, 5, 2, 1]`.  
Потрібно для заданої суми знайти, як видати решту монетами:

- за допомогою жадібного алгоритму (`find_coins_greedy`);
- за допомогою алгоритму динамічного програмування (`find_min_coins`).

Обидві функції повертають словник формату `{номінал: кількість}`.  
Наприклад, для суми `113` обидва алгоритми дають:
`{50: 2, 10: 1, 2: 1, 1: 1}` (порядок ключів у словнику може відрізнятися).

## Жадібний алгоритм

Ідея жадібного алгоритму:

1. Взяти найбільший номінал монети (50).
2. Взяти від нього максимально можливу кількість монет.
3. Зменшити суму на видану кількість.
4. Перейти до наступного меншого номіналу.
5. Повторювати, поки решта не стане 0.

### Складність

Нехай `k` — кількість різних номіналів монет (у нашому випадку це 6).  
Тоді:

- **Часова складність:** `O(k)` — ми один раз проходимо по списку монет.
- **Просторова складність:** `O(1)` (якщо не рахувати словник з відповіддю, який і так потрібен).

Для нашого набору монет жадібний алгоритм завжди знаходить оптимальне (мінімальне) число монет.

## Динамічне програмування

Ідея алгоритму динамічного програмування:

1. Створити масив `min_coins` розміром `amount + 1`, де
   `min_coins[i]` — мінімальна кількість монет для суми `i`.
2. Початкове значення:
   - `min_coins[0] = 0`,
   - всі інші — `∞` (дуже велике число).
3. Для кожної суми `i` від 1 до `amount` перебрати всі номінали монет `coin`:
   - якщо `coin <= i`, перевірити, чи вигідно додати монету `coin`:
     `min_coins[i - coin] + 1 < min_coins[i]`.
   - якщо так — оновити `min_coins[i]` і запам’ятати, яку монету використали останньою.
4. Після заповнення таблиці відновити відповідь, «йдучи назад» від `amount` до 0.

### Складність

Нехай:

- `S` — сума, для якої шукаємо розбиття,
- `k` — кількість номіналів монет.

Тоді:

- **Часова складність:** `O(k * S)` — для кожної суми від 1 до `S` ми перебираємо всі монети.
- **Просторова складність:** `O(S)` — таблиці `min_coins` і `last_coin`.

Алгоритм динамічного програмування завжди знаходить **оптимальне рішення**, навіть у тих випадках, коли жадібний алгоритм дає не мінімальну кількість монет (це можливо для інших наборів монет, наприклад `[10, 6, 1]`).

## Порівняння ефективності на великих сумах

У коді додано заміри часу виконання з використанням модуля `timeit`:

- Для декількох сум (`113`, `999`, `5000`) вимірюється час виконання:
  - `find_coins_greedy` — 1000 запусків,
  - `find_min_coins` — 100 запусків.

### Висновки

1. **Жадібний алгоритм**
   - Працює дуже швидко, час практично не змінюється зі збільшенням суми.
   - Має складність `O(k)`, де `k` — кількість номіналів монет.
   - Для нашого конкретного набору монет `[50, 25, 10, 5, 2, 1]` дає оптимальне рішення.
   - Підходить для касових апаратів, де важлива швидкість обробки великої кількості операцій.

2. **Алгоритм динамічного програмування**
   - Гарантовано знаходить мінімальну кількість монет для будь-якого набору номіналів.
   - Має складність `O(k * S)`, тому час виконання зростає разом із сумою `S`.
   - На великих сумах (тисячі та більше) помітно повільніший за жадібний алгоритм.

3. **Загальний висновок**
   - Якщо набір монет «гарний» (як у нашому випадку), жадібний алгоритм простіший і швидший, і його достатньо для реальної касової системи.
   - Якщо набір монет може бути будь-яким, або важливо завжди мати **строго мінімальну** кількість монет, тоді краще використовувати алгоритм динамічного програмування, навіть попри його більшу вартість за часом і пам’яттю.

# Завдання 2. Метод Монте-Карло для обчислення інтеграла

## Постановка задачі

Мета завдання — обчислити значення визначеного інтеграла функції методом Монте-Карло та перевірити правильність результату за допомогою:

- аналітичного обчислення інтеграла;
- функції `quad` з модуля `scipy.integrate`.

Фактично ми шукаємо площу під графіком функції на заданому відрізку.

---

## Обрана функція

Для розв’язання задачі я обрала функцію:

f(x) = sin(x) + 2

на відрізку:

x ∈ [0, π]

Графік цієї функції на відрізку 0, π має хвилеподібну форму (через синус) і зміщений вгору на 2 одиниці, тому вся крива знаходиться вище осі Ox. Сіра заштрихована область під графіком між 0 та π і є шуканою площею (значенням інтеграла).

---

## Аналітичне обчислення інтеграла

Спочатку розіб’ємо функцію на дві частини:

- ∫ sin(x) dx  
- ∫ 2 dx  

### 1. Інтеграл від sin(x):

∫₀→π sin(x) dx = -cos(x) │₀→π  
			= -cos(π) - ( -cos(0) )  
			= -(-1) - (-1)  
			= 1 + 1 = **2**

### 2. Інтеграл від 2:

∫₀→π 2 dx = 2x │₀→π  
= 2π

### Підсумок:

∫₀→π (sin(x) + 2) dx = 2 + 2π ≈ **8.283185307**

Це значення використовувалося як еталон для порівняння з методом Монте-Карло.

---

## Ідея методу Монте-Карло

Метод Монте-Карло дозволяє обчислити площу під графіком за допомогою випадкових точок.

Основна ідея:

	1.	Вибираємо прямокутник, який повністю накриває графік функції на відрізку a, b.
	2.	Генеруємо багато випадкових точок усередині цього прямокутника.
	3.	Визначаємо, яка частка з них потрапила під криву.
	4.	Площа під кривою (інтеграл) ≈ площа прямокутника × частка точок під графіком.

Формально:

I ≈ Sₚ * p

де
Sₚ — площа прямокутника,
p — частка точок, що потрапили під графік.

---

## Графік функції

На графіку відображені:

 	- крива функції f(x) = sin(x) + 2,
	- межі інтегрування,
	- заштрихована область інтеграла.

Графік генерується з допомогою matplotlib у програмі.

---

## Програмна реалізація

Код реалізовано мовою Python з використанням бібліотек `numpy` та `scipy`.

Основні частини:

- функція `f(x)` — обрана функція;
- змінні `a` і `b` — межі інтегрування;
- константа `f_max` — верхня межа для прямокутника;
- функція `monte_carlo_integral(num_points)`, яка реалізує метод Монте-Карло.

Схема роботи `monte_carlo_integral`:

1. Генеруємо `num_points` випадкових значень `x` на відрізку `[a, b]`.
2. Генеруємо таку ж кількість випадкових значень `y` на відрізку `[0, f_max]`.
3. Обчислюємо, яка частка точок задовольняє умову `y <= f(x)`.
4. Множимо цю частку на площу прямокутника.

Також у блоці `if __name__ == "__main__":` виконуються:
- розрахунки методом Монте-Карло для різних кількостей точок (`N = 1000, 10000, 100000`);
- аналітичний розрахунок інтеграла;
- перевірка результату за допомогою `scipy.integrate.quad`;
- порівняння значень та виведення різниці.

---

## Перевірка результатів за допомогою `quad`

Для додаткової перевірки я скористалася функцією:

```python
from scipy.integrate import quad
```

## Висновки

1. Метод Монте-Карло дозволяє наближено обчислити значення визначеного інтеграла, розглядаючи інтеграл як площу під графіком функції.

2. Точність методу сильно залежить від кількості випадкових точок:
	- при невеликій кількості точок (N = 1000) результат може досить суттєво відхилятися
	- зі збільшенням N (до 10000, 100000 і більше) оцінка інтеграла стабілізується та наближається до точного значення.

3. Порівняння з аналітичним результатом та значенням, отриманим за допомогою функції `quad`, показує, що метод Монте-Карло працює правильно: середнє значення інтеграла наближається до точного результату, хоча завжди містить випадкову похибку.

4. Для одновимірних інтегралів функція quad зазвичай точніша й швидша за метод Монте-Карло, але Монте-Карло є більш універсальним підходом для складних багатовимірних задач та нетривіальних областей інтегрування.



